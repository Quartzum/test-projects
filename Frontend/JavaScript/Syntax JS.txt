Принцип написания кода:
==================================================================================================
camelCase - Верблюжий язык. В JS пишем название переменных строго в таком стиле.
Первое слово с маленькой буквы, а второй с большой. Этой системы придерживаются все функции языка.

Закрытие строки:
==================================================================================================
В конце строки можно ставить ; , а можно не ставить. Лучше не ставить, т.к. код становится чище.

Конкатенация:
==================================================================================================
Конкатенация - сложение объектов линейной структуры, чаще всего строк.

Обьявление переменных и констант:
==================================================================================================
Переменную можно оставить пустой, а константе обязательно нужно дать значение.

Обьявление переменной внутри функции:
==================================================================================================
Если объявить переменную внутри функции, то за пределами функции ее не будет.

Область видимости:
==================================================================================================
Функциональная область видимости - это то, что интерпретатор видит внутри какой-либо функции.
Область видимости внутри блока кода - это то, что видит интерпретатор внутри всего кода,
за исключением var в функциях.

Область видимости let, const и var:
==================================================================================================
let и const - имеют функциональную область видимости.

var - общую область видимости. То есть ее будет видно везде.

Динамическая типизация:
==================================================================================================
в JS нет необходимости указывать тип данных в переменной.

Значение функции:
==================================================================================================
Если мы пропишем функцию, но не укажем, что она должна делать,
то она будет возвращать нам в консоле - undefind.

Работа с BigInt:
==================================================================================================
console.log(9000000000000000000000000000n) - допустимо
console.log(9000000000000000000000000000n+90000000000000000000n) - допустимо
console.log(9999999999999999999999999n+999 + 'string') - недопустимо

Symbol при переборе в цикле for - in:
==================================================================================================
Если перебирать свойства через цикл for - in, то свойство заданное через symbol
не будет учавствовать в подборе.

Операции сравнения:
==================================================================================================
Так как JS нестроготпизированный язык, то при нестрогом сравнении значений переменных,
он приводит значение к чему-то одному.

Принцип DRY:
==================================================================================================
Дословно переводится Don't repeat youself - Не повторяй себя.

Нейминг функций:
==================================================================================================
Названия функциям лучше всего давать глаголами

Пример:
function sayHi()

Принцип чтения кода в JS:
==================================================================================================
Движок JS читает код два раза. В первый раз он читает код сверху вниз и запоминает переменные.
Второй раз он уже выполняет весь код сверху вниз.

Принцип работы return:
==================================================================================================
То, что написано после return внутри функции, не будет выполнено.

Сложение undefind:
==================================================================================================
При сложении undefind он выдаст в консоли NaN

Работа с массивами:
==================================================================================================
Лучше всего использовать однородные значения в массив. То есть он должен быть целостный.
Например массив чисел, массив текста и т.п.

Использование константы при создании массива:
==================================================================================================
Хоть мы и используем константу для хранения массива, это не значит, что мы не можем изменить массив.
В данном случаи константа(контейнер) ссылается на массив где-то внутри памяти,
поэтому сам массив мы можем менять.

Но если мы попытаемся где-то дальше объявить эту же константу,
и сослаться на другой массив, то это выдаст ошибку.

Если же мы сделаем новую переменную и сделаем так, что они будут похожи,
то это будет ни одним и тем же массивом.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']
let array = ['Audi', 'BMW', 'Mazda', 'Toyota']

Это два разных массива и они не будут равны.

Смысл в том, что переменные ссылаются на РАЗНЫЕ массивы в области памяти. 
autoBrands один массив, а array другой.

Работа с объектами:
==================================================================================================
const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
}

console.log(person) - выдаст объект с параметрами userName, age, isMarried.
console.log(person.userName) - выдаст в консоли параметр userName.

person.profession = 'JS developer' - добавление параметра объекту.
console.log(person) - выдаст объект с параметрами userName, age, isMarried.

НО если открыть объект внутри терминала, на первом выводе, то он найдет
там профессию, хотя строчка лога сработала до введения свойства профессия.


Разница между циклом for of и for in:
==================================================================================================
for of - использовать для массива(интерируемая переменная)
for in - использовать для объектов(неинтерируемый объект). Он возвращает ключи.