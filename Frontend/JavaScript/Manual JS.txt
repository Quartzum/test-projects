1)Переменная и постоянная.
==================================================================================================
Это контейнер, в котором мы можем хранить значения.

1)let - переменная, в которой значение можно поменять.
2)const - постоянная, в которой значение не меняется.
3)var - тоже самое, что и let. Использовался до ES5.
Примечание: отличается от let тем, что интерпретатор видит его даже внутри функции.

Лучше всего использовать всегда const!!!!!

Пример:

1)let name = 'name'
2)const name = 'name'
3)var name = 'name'

Название перменных:

Можно начинать ее со спец.символа:

const _name = name
const _ = n

Нельзя называть переменную зарезервированными словами в языке(типо is, for и т.п.)
Нельзя называть переменную начиная с цифры(9name - нельзя)

2)Мутирование.
==================================================================================================
const nameName = 144
console.log('Введите данные: ' + nameName)

Здесь произойдет процесс конкатенации. То есть первое значение склеиться со вторым значением.
При этом переменная Name станет строкой, а не числом,как было до этого. 
Это происходит из-за того, что строка главнее числа. 
Есть специальная таблица по которой можно определить важность данных.

3)Типы данных.
==================================================================================================
1)'string' - string(строка).
2)23 - number(число).
3)true/false - boolean(булево число). Может принимать значение true или false.
4)null - null(ничего). Значение неизвестно. Используют для сброса значения переменной.
5)undefind - значение не определенно. Пример - let name. 
Здесь в значение ничего не записано, поэтому оно будет выводится, как undefind.

6)BigInt - встроенный объект, который позволяет создавать большие числа. 
Если необходимо выйти за Number_Max_integer, то нужно использовать BigInt.
7)Symbol - это уникальное примитивное значение. 
Позволяет добавлять уникальное свойство к объекту, с уверенностью,
что он не перезапишет никакое другое свойство.

4)Операторы сравнения и условия.
==================================================================================================
> - больше
< - меньше
>= - больше, либо равно.
<= - меньше, либо равно.
== - нестрогое сравнение.
=== - строгое сравнение.
!= - нестрогое неравенство.
!== - строгое неравенство.

if(условие){} - оператор условия если. Если условие верно, 
то он выполнит часть в фигурных скобках.

else{} - оператор условия иначе. Если условия выше else не верны, 
то он выполнит часть кода в фигурных скобках.

5)Логические операторы.
==================================================================================================
&& - логическое И.
|| - логическое ИЛИ.
!true - логическое НЕ.

6)Тернарный оператор.
==================================================================================================
Это упрощенная конструкция с операторами if и else.

1)Конструкция на If/else:

let greeting
let time = 10

if (time < 12){
    greeting = 'Доброе утро'
} else{
    greeting = 'Добрый день'
}

console.log(greeting)

2)Конструкция на тернарном операторе:

let time = 10
greeting = time < 12 ? 'Доброе утро' : 'Добрый день'
console.log(greeting)

7)Конкатенация строк и шаблонные строки
==================================================================================================

Конкатенация - сложение строк.

let greeting = 'Привет, Марк!'
let howAreTou = 'Как твои дела?'
let sayHi = greeting + howAreTou
console.log(sayHi)

Шаблонные строки - это строки, в которые напрямую можно вставить значение переменной.
Плюс в том, что не происходит перетипизация переменной(то есть не происходит переход от одного типа данных
к другому и как следствие не будет случайных ошибок).

Объявляется при помощи обратных скобок `` и там, где мы хотим вставить переменную ${}

console.log(`Привет, ${userName}! Как твои дела?`)

//---------------------------------------------------------------------------------------------------------------------------------------

8)Функции

Функция - это конструкция, которая позволяет вызывать ее внутри кода неограниченное количество раз.

function name(){

}

function(name)

function declaration - это функция, которую JS может выполнить при первом чтении скрипта.
То есть, если мы функцию написали ниже, а запустили функцию выше, то он ее выполнит и это не будет ошибкой.

function sayHi()

function sayHi(){
    alert('Привет')
}
_________________________________________________________________________

function expression - это функция, которую JS может вызвать через переменную.

const sayHi = function(){
    alert('Привет')
}

function sayHi()

Если вызвать функцию раньше написания самой функции, то выдаст ошибку.

//-------------------------------------------------------------------------------------------------------------------------------------------

9)Параметры и аргументы для функции

function sayHi(name){
    console.log(`Привет, ${name}! Как твои дела?`)
}

sayHi('Yurij')

name - Параметр
Yurij - Аргумент

//----------------------------------------------------------------------------------------------------------------------

10)Return

Это часть кода, которая возвращает значение чего-то куда-то.

function summ(a, b){
    const result = a + b 
    return result;
}

let res = summ(10, 15)
console.log(res)

//---------------------------------------------------------------------------------------------------------------------------------

11)Функция, как аргумент.

function summ(a, b){
    return a+b
}

console.log(summ(10, 15))

const result = summ(summ(15, 15), summ(20, 20))

//----------------------------------------------------------------------------------------------------------------------------------

12)Самовызывающаяся функция IIFE.

Immediately involve function expression - Незамедлительно вызывающаяся функциональной выражение.

Пример:

(function sayHi(){
    console.log('Привет, дорогой пользователь!');
})();

То есть можно не вызывать отдельно где-то функцию, а вызвать ее внутри нее.

(function(){
    console.log('Привет, дорогой пользователь!');
})();

Также можно сделать анонимную IIFE, как примером выше.

ТАКЖЕ ОБЯЗАТЕЛЬНО СТАВИТЬ ТОЧКУ С ЗАПЯТОЙ В КОНЦЕ ФУНКЦИЙ

В круглые скобки в конце вносим аргументы функции.

//---------------------------------------------------------------------------------------------------------------------
13)Стрелочные функции

Выражения стрелочных функций имеют более короткий синтаксис по сравнению
с функциональными выражениями и лексически привязаны к значению this 
(но не привязаны к собственному this, arguments, super, или new.target). Выражение стрелочных функций не позволяют задавать имя, поэтому стрелочные функции анонимны, если их ни к чему не присвоить.

const SayHi = (name) => {
    console.log(`Привет, ${name}! Как твои дела?`)
}
SayHi()

const sayHi = (name) => console.log(`Привет, ${name}! Как твои дела?`)
sayHi('Марк')

const summ = (a, b) => a + b

//-------------------------------------------------------------------------------------------------------------------------------------

14)Массивы

Это коллекция данных

Если в коде есть [], то это либо array(массив), либо массивоподобные конструкции.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']
console.log(autoBrands)

Если нужно вывести конкретный элемент внутри массива, то можно использовать следующую команду:

console.log(autoBrands[0]) - отсчет начинается с 0.

console.log(autoBrands.length) - длинна массива

Внутрь массива можно внести другой массив.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota', [2,3,4]]

//-------------------------------------------------------------------------------------------------------------------------------------------------

15)Методы массивов.

.push() - добавляет элемент в конец массива.
.pop() - удалить элемент из конца массива.
.shift() - удалить элемент из начала массива.
.unshift() - добавь элемент в начало массива.
.splice() - удалить элемент с какого-то конкретного места.
.slice() - вырезает и возвращает указанную часть массива.
.forEach() - позволяет последовательно перебрать все элементы массива.
.indexOf()  - возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет.
.includes() - определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.

Примеры:

autoBrands.push(23)
autoBrands.pop(43)
autoBrands.shift(6)
autoBrands.unshift(4)
autoBrands.splice(2, 1) - начать со второго элемента, а второй параметр указывает на количество удалений.

массив.slice(откуда отрезать, 
	[докуда отрезать]

массив.forEach(function(элемент, индекс, 
	массив) { 
	код, который выполнится для всех 
		элементов 
})

arr.indexOf(searchElement[, fromIndex = 0])

arr.includes(searchElement[, fromIndex = 0])

//----------------------------------------------------------------------------------------------------------------------------------

16)Циклы

Он позволяет запустить код несколько раз, пока цикл не закончится.

console.log('Start')

for(let i = 0; i < 10; i++){
    console.log(i)
}

console.log('Finish')

Первый параметр - количество циклов.
Второй параметр - условие цикла.
Третий параметр - что мы делаем с циклом.
_____________________________________________________________________________

Обход массива циклом for

При помощи него можно пройтись по каждому элементу через индекс(или что-то еще)массива

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']
for (i = 0; i < autoBrands.length; i++){
    console.log(autoBrands[i])
}

_____________________________________________________________________________

Обход массива циклом for (of)

Более легкий и лаконичный способ обхода массива с самого начала

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']

for(let brand of autoBrands){
    console.log(brand)
}

_________________________________________________________________________

Обход массива методом forEach()

Функцию внутри метода можно сразу написать.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']

autoBrands.forEach(function(item, index){
    console.log(`${item} => ${index}`)
})

Или можно описать функцию где-то ниже...

autoBrands.forEach(printBrand)

function printBrand(item, index){
    console.log(`${item} => ${index}`)
})

Также можно вызвать функцию через метод и передать ей значения

autoBrands.forEach(printBrand(1, 2))

function printBrand(item, index){
    console.log(`${item} => ${index}`)
})

Также стрелочная функция при этом методе

autoBrands.forEach((brand, i) =>console.log(`${brand} => ${i}`))

//---------------------------------------------------------------------------------------------------------------------------------

17.Объекты

let userName = 'Марк'
let age = 30
let isMarried = false

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    profession: 'Designer'
}

console.log(person)

console.log(person.userName) - обращение по свойству
console.log(person['age']) - обращение по свойству. Лучше всего использовать, когда
свойство занесено в переменную.

let propertyName = 'profession'
const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    profession: 'Designer'
}

console.log(person[propertyName])

person.profession = 'JS developer' - так можно добавить свойство в объект.

delete person.age - удаление свойства
console.log(person)

//---------------------------------------------------------------------------------------------------------------

18)Методы в объектах

Функция, которая принадлежит объекту называется методом объекта.
Остальное, что внутри объекта это свойства(юзер нейм, возраст ...)

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(){
        console.log('Привет!')
    }
}

person.sayHi() - запуск метода

person.sayHi = function(){      - добавить метод в объект
        console.log('Привет!')
    }

person.sayHi()


person.sayHi = function(name){      - добавить параметр в метод объекта
        console.log(`Привет, $(name)!`)
    }

person.sayHi('Юрий')

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(name){
        console.log(`Привет, ${name}!`)
    }
}

person.sayHi('Юрий')

//----------------------------------------------------------------------------------------------------

19)Ключевое слово this

Ключевое слово this внутри метода объекта ссылается на объект.

Можно обратиться напрямую к объекту person на свойство userName, но проблема в том,
что мы обращаемся внутри объекта на объект.

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(name){
        console.log(`Привет, ${name}! Меня зовут ${person.userName}.`)
    }
}

person.sayHi('Юрий')

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(name){
        console.log(this)
        console.log(`Привет, ${name}! Меня зовут ${this.userName}.`)
    }
}

person.sayHi('Юрий')

//----------------------------------------------------------------------------------------------------------------------------------------------------

20)Объекты обход циклом for in (не путать с for of)

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(yourName){
        console.log(this)
        console.log(`Привет, ${yourName}! Меня зовут ${this.userName}.`)
    }
}

for (let key in person){
    console.log(key) - обычный обход по ключу
    console.log(key, ':', person[key]) - обход по ключу, + значение свойств.

//-----------------------------------------------------------------------------------------------------------------------------------------------------------

21)Нюанс const и изменение объекта и массива


При попытки добавить что-то в объект это не будет ошибкой

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
}

person.proff = 'Designer'

Ошибка! Переопределение ссылки на новый объект

person = {
    userName = 'Ник'
}

//-----------------------------------------------------------------------------------------------------------------------------------

22)Классы. Конструкторы объектов

Используются, когда нужно описать большое количество объектов.

Класс, это как чертеж для всех будущих объектов person, которые будут создаваться на его основе

class Person{
    constructor(userName, age, isMarried){
        this.userName = userName
        this.age = age
        this.isMarried = isMarried
    }

    sayHi(name){
        console.log(`Привет, ${name}! Меня зовут ${this.userName}.`)
    }
}

const person1 = new Person('Марк', 30, false)
const person2 = new Person('Павел', 28, true)

console.log(person1)
person1.sayHi('Юрий')

//----------------------------------------------------------------------------------------------------------------------------------------------
Все, что ниже по курсу отходится к Web

23)Выбор DOM элементов

Выбор одного элемента DOM по селектору

document.querySelector('selector') - c помощью скобок можно
обратиться к тегу, селектору, id или классу.
Также можно использовать составные селекторы.

Это команда возвращает только один элемент

document.querySelector('.heading-3').classList.add('green') - добавление свойства CSS по классу.

Выбор коллекции элементов через цикл for

1)Ищем все теги h2.
const headings = document.querySelectorAll('h2')
console.log(headings)
2)Проходимся циклом for для заголовков и красим текст к красный.
for (let heading of headings) {
    heading.classList.add('red-text')
}

Выбор коллекции элементов через цикл for

const paragraphs = document.querySelectorAll('p')
paragraphs.forEach(function (item){
    item.classList.add('green-text')
})

Старые методы:

document.getElementsByClassName('selector') - выбор коллекции элементов по CSS классу
document.getElementsByTagName('selector') - выбор коллекции элементов по тегу
document.getElementById('selector') - выбор одного элемента по ID

Точки и # во всех методах писать не надо, т.к. метод подразумевает, что мы работаем с классами и ID.

//-------------------------------------------------------------------------------------------------------------------------------------------------

24)Работа с CSS классами

element.classList.add() - на первом месте класс, на втором класс метода, на третьем метод
.add() - добавить CSS класс
.remove() - удалить CSS класс
.toggle() - добавляет или убирает CSS класс(в зависимости от того есть он там или нет)
.contains() - возвращает true или false в зависимости от того есть такой класс или нет.

//-------------------------------------------------------------------------------------------------------------------------------------------------------------

25)Работа с атрибутами

getAttribute(attrName) - возвращает значение указаного атрибута
setAttribute(name, value) - добавляет указанные атрибут и значение к элементу
hasAttribute(attrName) - возвращает true при наличии у элемента указанного атрибута
removeAttribute(attrName) - удаляет указанный атрибут
toggleAttribute(name, force) - добавляет новый атрибут при отсутствии или удаляет существующий атрибут.
hasAttributes() - возвращает true, если у элемента имеются какие-либо атрибуты
getAttributesNames() - возвращает названия атрибутов элемента
