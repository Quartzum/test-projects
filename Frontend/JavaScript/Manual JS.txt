1)Переменная и постоянная.
==================================================================================================
Это контейнер, в котором мы можем хранить значения.

1)let - переменная, в которой значение можно поменять.
2)const - постоянная, в которой значение не меняется.
3)var - тоже самое, что и let. Использовался до ES5.
Примечание: отличается от let тем, что интерпретатор видит его даже внутри функции.

Лучше всего использовать всегда const!!!!!

Пример:

1)let name = 'name'
2)const name = 'name'
3)var name = 'name'

Название перменных:

Можно начинать ее со спец.символа:

const _name = name
const _ = n

Нельзя называть переменную зарезервированными словами в языке(типо is, for и т.п.)
Нельзя называть переменную начиная с цифры(9name - нельзя)

2)Мутирование.
==================================================================================================
const nameName = 144
console.log('Введите данные: ' + nameName)

Здесь произойдет процесс конкатенации. То есть первое значение склеиться со вторым значением.
При этом переменная Name станет строкой, а не числом,как было до этого. 
Это происходит из-за того, что строка главнее числа. 
Есть специальная таблица по которой можно определить важность данных.

3)Типы данных.
==================================================================================================
1)'string' - string(строка).
2)23 - number(число).
3)true/false - boolean(булево число). Может принимать значение true или false.
4)null - null(ничего). Значение неизвестно. Используют для сброса значения переменной.
5)undefind - значение не определенно. Пример - let name. 
Здесь в значение ничего не записано, поэтому оно будет выводится, как undefind.

6)BigInt - встроенный объект, который позволяет создавать большие числа. 
Если необходимо выйти за Number_Max_integer, то нужно использовать BigInt.
7)Symbol - это уникальное примитивное значение. 
Позволяет добавлять уникальное свойство к объекту, с уверенностью,
что он не перезапишет никакое другое свойство.

4)Операторы сравнения и условия.
==================================================================================================
> - больше
< - меньше
>= - больше, либо равно.
<= - меньше, либо равно.
== - нестрогое сравнение.
=== - строгое сравнение.
!= - нестрогое неравенство.
!== - строгое неравенство.

if(условие){} - оператор условия если. Если условие верно, 
то он выполнит часть в фигурных скобках.

else{} - оператор условия иначе. Если условия выше else не верны, 
то он выполнит часть кода в фигурных скобках.

5)Логические операторы.
==================================================================================================
&& - логическое И.
|| - логическое ИЛИ.
!true - логическое НЕ.

6)Тернарный оператор.
==================================================================================================
Это упрощенная конструкция с операторами if и else.

1)Конструкция на If/else:

let greeting
let time = 10

if (time < 12){
    greeting = 'Доброе утро'
} else{
    greeting = 'Добрый день'
}

console.log(greeting)

2)Конструкция на тернарном операторе:

let time = 10
greeting = time < 12 ? 'Доброе утро' : 'Добрый день'
console.log(greeting)

7)Конкатенация строк и шаблонные строки.
==================================================================================================
Конкатенация - сложение строк.

let greeting = 'Привет, Марк!'
let howAreTou = 'Как твои дела?'
let sayHi = greeting + howAreTou
console.log(sayHi)

Шаблонные строки - это строки, в которые напрямую можно вставить значение переменной.
Плюс в том, что не происходит перетипизация переменной
(то есть не происходит переход от одного типа данных
к другому и как следствие не будет случайных ошибок).

Объявляется при помощи обратных скобок `` и там, где мы хотим вставить переменную ${}

console.log(`Привет, ${userName}! Как твои дела?`)

8)Функции.
==================================================================================================
Функция - это конструкция, которая позволяет вызывать ее внутри кода неограниченное количество раз.

function name(){
}

function(name)

1)Function declaration - это функция, которая находится в глобальном коде, а не внутри какой-то 
переменной или постоянной. Мы ее можем вызвать в любое время.

function sayHi()

function sayHi(){
    alert('Привет')
}


2)Function expression - это функция, которая записывается в переменную или постоянную.

const sayHi = function(){
    alert('Привет')
}

function sayHi()

Если вызвать функцию раньше написания самой функции, то выдаст ошибку.

8.1)Параметры и аргументы для функции.
==================================================================================================
function sayHi(name){
    console.log(`Привет, ${name}! Как твои дела?`)
}

sayHi('Yurij')

name - Параметр
Yurij - Аргумент

8.2)Функция Return.
==================================================================================================
Функция Return - завершает выполнение текущей функции и возвращает её значение
(чаще всего в какую-то переменную или постоянную).

function summ(a, b){
    const result = a + b 
    return result;
}

let res = summ(10, 15)
console.log(res)

8.3)Функция, как аргумент.
==================================================================================================
function summ(a, b){
    return a+b
}

console.log(summ(10, 15))

const result = summ(summ(15, 15), summ(20, 20))

8.4)Самовызывающаяся функция IIFE.
==================================================================================================
Immediately involve function expression - Незамедлительно Вызывающееся Функциональное выражение.

Пример:

(function sayHi(){
    console.log('Привет, дорогой пользователь!');
})();

То есть можно не вызывать отдельно где-то функцию, а вызвать ее внутри нее.

(function(){
    console.log('Привет, дорогой пользователь!');
})();

Также можно сделать анонимную IIFE, как примером выше.

ТАКЖЕ ОБЯЗАТЕЛЬНО СТАВИТЬ ТОЧКУ С ЗАПЯТОЙ В КОНЦЕ ФУНКЦИИ!!!

В круглые скобки в конце вносим аргументы функции.

8.5)Стрелочные функции.
==================================================================================================
Выражения стрелочных функций имеют более короткий синтаксис по сравнению
с функциональными выражениями и лексически привязаны к значению this.
(но не привязаны к собственному this, arguments, super, или new.target). 
Выражение стрелочных функций не позволяют задавать имя, поэтому стрелочные функции анонимны, 
если их ни к чему не присвоить.

const SayHi = (name) => {
    console.log(`Привет, ${name}! Как твои дела?`)
}
SayHi()

const sayHi = (name) => console.log(`Привет, ${name}! Как твои дела?`)
sayHi('Марк')

const summ = (a, b) => a + b

9)Массивы.
==================================================================================================
Это коллекция данных

Если в коде есть [], то это либо array(массив), либо массивоподобные конструкции.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']
console.log(autoBrands)

Если нужно вывести конкретный элемент внутри массива, то можно использовать следующую команду:

console.log(autoBrands[0]) - отсчет начинается с 0.

console.log(autoBrands.length) - длинна массива

Внутрь массива можно внести другой массив.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota', [2,3,4]]

9.1)Методы массивов.
==================================================================================================
1).push() - добавляет элемент в конец массива.
2).pop() - удалить элемент из конца массива.
3).shift() - удалить элемент из начала массива.
4).unshift() - добавь элемент в начало массива.
5).splice() - удалить элемент с какого-то конкретного места.
6).slice() - вырезает и возвращает указанную часть массива.
7).forEach() - позволяет последовательно перебрать все элементы массива.
8).indexOf()  - возвращает первый индекс, по которому данный элемент может быть
найден в массиве или -1, если такого индекса нет.
9).includes() - определяет, содержит ли массив определённый элемент, 
возвращая в зависимости от этого true или false.

Примеры:

autoBrands.push(23)
autoBrands.pop(43)
autoBrands.shift(6)
autoBrands.unshift(4)
autoBrands.splice(2, 1) - начать со второго элемента, а второй параметр указывает
на количество удалений.

массив.slice(откуда отрезать, 
	[докуда отрезать]

массив.forEach(function(элемент, индекс, 
	массив) { 
	код, который выполнится для всех 
		элементов 
})

arr.indexOf(searchElement[, fromIndex = 0])

arr.includes(searchElement[, fromIndex = 0])

10)Циклы.
==================================================================================================
Он позволяет запустить код несколько раз, пока цикл не закончится.

console.log('Start')

for(let i = 0; i < 10; i++){
    console.log(i)
}

console.log('Finish')

Первый параметр - количество циклов.
Второй параметр - условие цикла.
Третий параметр - что мы делаем с циклом.


11.1)Обход массива циклом for.
==================================================================================================
При помощи него можно пройтись по каждому элементу через индекс(или что-то еще)массива

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']
for (i = 0; i < autoBrands.length; i++){
    console.log(autoBrands[i])
}

11.2)Обход массива циклом for (of)
==================================================================================================
Более легкий и лаконичный способ обхода массива с самого начала.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']

for(let brand of autoBrands){
    console.log(brand)
}

11.3)Обход массива методом forEach().
==================================================================================================
Функцию внутри метода можно сразу написать.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']

autoBrands.forEach(function(item, index){
    console.log(`${item} => ${index}`)
})

Или можно описать функцию где-то ниже...

autoBrands.forEach(printBrand)

function printBrand(item, index){
    console.log(`${item} => ${index}`)
})

Также можно вызвать функцию через метод и передать ей значения

autoBrands.forEach(printBrand(1, 2))

function printBrand(item, index){
    console.log(`${item} => ${index}`)
})

Также стрелочная функция при этом методе

autoBrands.forEach((brand, i) =>console.log(`${brand} => ${i}`))


12)Объекты.
==================================================================================================
let userName = 'Марк'
let age = 30
let isMarried = false

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    profession: 'Designer'
}

console.log(person)

console.log(person.userName) - обращение по свойству
console.log(person['age']) - обращение по свойству. Лучше всего использовать, когда
свойство занесено в переменную.

let propertyName = 'profession'
const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    profession: 'Designer'
}

console.log(person[propertyName])

person.profession = 'JS developer' - так можно добавить свойство в объект.

delete person.age - удаление свойства
console.log(person)


12.1)Методы в объектах
==================================================================================================
Функция, которая принадлежит объекту называется методом объекта.
Остальное, что внутри объекта это свойства(юзер нейм, возраст ...)

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(){
        console.log('Привет!')
    }
}

person.sayHi() - запуск метода

person.sayHi = function(){      - добавить метод в объект
        console.log('Привет!')
    }

person.sayHi()


person.sayHi = function(name){    - добавить параметр в метод объекта
    console.log(`Привет, ${name}`)
}

person.sayHi('Юрий')

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(name){
        console.log(`Привет, ${name}!`)
    }
}

person.sayHi('Юрий')


12.2)Ключевое слово this.
==================================================================================================
Ключевое слово this внутри метода объекта ссылается на объект.

Можно обратиться напрямую к объекту person на свойство userName, но проблема в том,
что мы обращаемся внутри объекта на объект.

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(name){
        console.log(`Привет, ${name}! Меня зовут ${person.userName}.`)
    }
}

person.sayHi('Юрий')

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(name){
        console.log(this)
        console.log(`Привет, ${name}! Меня зовут ${this.userName}.`)
    }
}

person.sayHi('Юрий')

12.3)Объекты обход циклом for in (не путать с for of).
==================================================================================================
const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(yourName){
        console.log(this)
        console.log(`Привет, ${yourName}! Меня зовут ${this.userName}.`)
    }
}

for (let key in person){
    console.log(key) - обычный обход по ключу
    console.log(key, ':', person[key]) - обход по ключу, + значение свойств.

12.4)Нюанс const и изменение объекта и массива.
==================================================================================================
При попытки добавить что-то в объект это не будет ошибкой.

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
}

person.proff = 'Designer'

Ошибка! Переопределение ссылки на новый объект.

person = {
    userName = 'Ник'
}

13)Классы. Конструкторы объектов.
==================================================================================================
Используются, когда нужно описать большое количество объектов.

Класс, это как чертеж для всех будущих объектов person, которые будут создаваться на его основе

class Person{
    constructor(userName, age, isMarried){
        this.userName = userName
        this.age = age
        this.isMarried = isMarried
    }

    sayHi(name){
        console.log(`Привет, ${name}! Меня зовут ${this.userName}.`)
    }
}

const person1 = new Person('Марк', 30, false)
const person2 = new Person('Павел', 28, true)

console.log(person1)
person1.sayHi('Юрий')

==================================================================================================
==================================================================================================
==================================================================================================
==================================================================================================
Web конструкции JavaScipt
==================================================================================================
==================================================================================================
==================================================================================================
==================================================================================================

1)Выбор DOM элементов
==================================================================================================
document - обращение к документу(в данном случаи, к HTML).
querySelector - обращение к селектору(тегу, классу, ID).
В скобках можно использовать составные теги(h2.heading ...).

document.querySelector('selector') - структура.
document.querySelector('.heading-3').classList.add('green') - добавление свойства CSS по классу.

Метод querySelector - работает только с первым селектором, который попадется.

document.querySelectorAll('selector') - работа с несколькими селекторами одновременно.

Не работает без цикла for.

1.1)Выбор коллекции элементов через цикл for of.
==================================================================================================
1)Ищем все теги h2.

const headings = document.querySelectorAll('h2')
console.log(headings)

2)Проходимся циклом for для заголовков и красим текст к красный.
for (let heading of headings) {
    heading.classList.add('red-text')
}

1.2)Выбор коллекции элементов через цикл forEach.
==================================================================================================
const paragraphs = document.querySelectorAll('p')
paragraphs.forEach(function (item){
    item.classList.add('green-text')
})

Старые методы:

document.getElementsByClassName('selector') - выбор коллекции элементов по CSS классу(нельзя использовать с циклом
forEach. Либо ее будет нужно превратить в массив).
document.getElementsByTagName('selector') - выбор коллекции элементов по тегу
document.getElementById('selector') -lin выбор одного элемента по ID

Точки и # во всех методах писать не надо, т.к. метод подразумевает,
что мы работаем с классами и ID.

2)Работа с CSS классами.
==================================================================================================
1)element.classList.add() - на первом месте класс, на втором класс метода, на третьем метод.
2).add() - добавить CSS класс.
3).remove() - удалить CSS класс.
4).toggle() - добавляет или убирает CSS класс(в зависимости от того есть он там или нет).
5).contains() - возвращает true или false в зависимости от того есть такой класс или нет.

2.1)Работа с атрибутами.
==================================================================================================
1)getAttribute(attrName) - возвращает значение указаного атрибута.
2)setAttribute(name, value) - добавляет указанные атрибут и значение к элементу.
3)hasAttribute(attrName) - возвращает true при наличии у элемента указанного атрибута.
4)removeAttribute(attrName) - удаляет указанный атрибут.
5)toggleAttribute(name, force) - добавляет новый атрибут при отсутствии
или удаляет существующий атрибут.
6)hasAttributes() - возвращает true, если у элемента имеются какие-либо атрибуты.
7)getAttributesNames() - возвращает названия атрибутов элемента.

const img = document.querySelector('#logo')
const srcValue = img.getAttribute('src')
console.log('srcValue')

Ищем элемент с ID logo, затем применяем к постоянной img метод getAttribute со значением src.
В консоли нам выдаст путь селектора, который мы искали по ID.

img.setAttribute('src', './img/js.png') - первое значение атрибут, а второй значение - то, что мы помещаем туда.

2.2)Работа с прослушкой событий.
==================================================================================================
Событие - это любое действие пользователя на экране веб-страницы(двинул мышкой, нажал на кнопку и т.п.)

1.Вывод информации о том, что пользователь кликнул на кнопку.

const button = document.querySelector('#button')
const img = document.querySelector('#logo')
button.value = 'Удалить'

button.addEventListener('click', function(){
    console.log('Click!')
})

2.Удаление тега с помощью метода .addEventListener.

const button = document.querySelector('#button')
const img = document.querySelector('#logo')
button.value = 'Удалить'

button.addEventListener('click', function(){
    console.log('Click!')
    img.remove()
})

Методов .addEventListener можно внести несколько обработчиков для одного и того же действия(например клика)
и, если мы запишем ниже еще несколько таких же обработчиков, то они будут все выполнятся и не перезапишутся.

const button = document.querySelector('#button')
const img = document.querySelector('#logo')
button.value = 'Удалить'

3.Удаление тега с помощью метода .onclick.

button.onclick = function(){
    console.log('Click!')
    img.remove()
}

Работает наооборот по сравнению с методом .addEventListener, то есть он будет перезаписывать обработчик ниже
по тексту.

4. Работа с формой.

const inputText = document.querySelector('#input-text')
const textBlock = document.querySelector('#text-block')

inputText.addEventListener('input', function(){
    console.log(inputText.value);
    textBlock.innerText = inputText.value;
})

С помощью этого скрипта можно сделать так, чтобы при заполнении формы, текст написанный в форме, попадал
в содержимое блока ниже.

5.Объект event.

const list = document.querySelector('#list')

list.addEventListener('click', function(event){
    console.log(this)
    console.log(event)
    console.log(event.target)
})

С помощью ключевого слова this мы ссылаемся на ID list.
С помощью аргумента функции event мы можем отслеживать на какой объект ткнул пользователь.
С помощью вывода через консоль event.target мы можем указать в логах, на что конкретно кликнул пользователь.

3)Работа с созданием объектов.
==================================================================================================
document.createElement('tag-name') - создать элемент.
element.innerHTML = '' - изменить HTML содержимое внутри элемента.
node.innerText = '' - изменить текстовое содержимое внутри элемента.
node.cloneNode() - клонирование элемента.(true с внутренним содержимым(текст и теги),
false - без внутреннего содержимого).
element.append(nodesOrDOMStrings) - вставить элемент внутрь другого элемента.
element.remove() - удалить элемент

//Выбор контейнера
const container = document.querySelector('#container')

//Создание заголовка
const newHeader = document.createElement('h1')
newHeader.innerText = 'Новый заголовок'
container.append(newHeader)

//Клонирование шапки
const mainHeader = document.querySelector('header')
const headerCopy = mainHeader.cloneNode(true)
//container.append(headerCopy)

//Вставка разметки через строки
const htmlExample = '<h2>Еще один заголовок</h2>'
container.insertAdjacentHTML('beforeend', htmlExample)

//Вставка разметки через шаблонные строки
const title = 'Текст заголовок'
const htmlExample = <h2>${title}</h2>
container.insertAdjacentHTML('beforeend', htmlExample)

Практические задания
==================================================================================================
==================================================================================================
1)Добавление нового элемента li с содержимым, внурь ul, при заполнении формы.
const todoList = document.querySelector('#todo-list')
const todoForm = document.querySelector('#todo-form')
const todoInput = document.querySelector('#todo-input')

todoForm.addEventListener('submit', formHandler)

function formHandler(event){
    event.preventDefault()

    //Получаем название задачи из Input

    const taskText = todoInput.value;
    console.log(taskText)

    //Создаем тег li через разметку

    const li = `<li>${taskText}</li>`
    console.log(li)

    //Добавляем разметку на страницу

    todoList.insertAdjacentHTML('beforeend', li)

    //Очищаем поле ввода

    todoInput.value = ''

    //Фокус на поле ввода
    
    todoInput.focus()
}
==================================================================================================

Другая реализация:

const todoList = document.querySelector('#todo-list')
const todoForm = document.querySelector('#todo-form')
const todoInput = document.querySelector('#todo-input')

todoForm.addEventListener('submit', formHandler)

function formHandler(event){
    event.preventDefault()
    const TaskText = todoInput.value

    //Создаем тег li с помощью создание элемента
    const newTask = document.createElement('li')
    newTask.innerText = TaskText

    todoList.append(newTask)

    todoInput.value =''
    todoInput.focus()
}

2)Удаление задачи

const todoList = document.querySelector('#todo-list')
const todoForm = document.querySelector('#todo-form')
const todoInput = document.querySelector('#todo-input')

todoForm.addEventListener('submit', formHandler)

function formHandler(event){
    event.preventDefault()
    const TaskText = todoInput.value

    //Создаем тег li с помощью создание элемента
    const newTask = document.createElement('li')
    newTask.innerText = TaskText

    //Создаем кнопку удалить
    const deleteBtn = document.createElement('button')
    deleteBtn.setAttribute('role','button')
    deleteBtn.innerText = 'Удалить'
    deleteBtn.style['margin-left'] = '15px'
    newTask.append(deleteBtn)

    //Добавляем событие на кнопку
    deleteBtn.addEventListener('click', function(){
        console.log(this)
        this.closest('li').remove()
    })

    //Добавить элемент на страницу
    todoList.append(newTask)

    todoInput.value =''
    todoInput.focus()
}

SetInterval
==================================================================================================
//Запуск таймера(код будет выполняться через промежуток времени)
const timerIntervalID = setInterval(function(){
    console.log('Fired!')
}, 1000)

//Остановка таймера
clearInterval(timerIntervalID)

SetTimeOut
==================================================================================================
const timerID = setTimeout(function(){
    console.log('setTimeout Fired!')
}, 5000)

clearInterval(timerID)

SetInterval + SetTimeOut
==================================================================================================
const timerID = setInterval(function(){
    console.log('setInterval Fired!')
 }, 1000)
 
 setTimeout(function(){
    clearInterval(timerID)
 }, 10000)

Секундомер
==================================================================================================
let counter = 0

setInterval(function(){
   counter = counter+1 - увеличивает значение переменной на одну.
   counter += 1 - делает тоже самое.
   counter++ - делает тоже самое.
}, 1000)

//Секундомер
const counterElement = document.querySelector('#counter')
let counter = 0
let timerID
//Старт
const btnStart = document.querySelector('#start')
btnStart.onclick = function(){
    timerID = setInterval(function(){
        counter++
        counterElement.innerText = counter
      }, 1000)
}
//Пауза
const btnPause = document.querySelector('#pause')
btnPause.onclick = function(){
   clearInterval(timerID)
}
//Сброс
const btnReset = document.querySelector('#reset')
btnReset.onclick = function(){
    counter = 0
    counterElement.innerText = counter
    clearInterval(timerID)
}

Callback.Callback hell(Ассинхронность JavaScipt)
==================================================================================================
console.log('Start')

setTimeout(function(){
    console.log('Print after 2s')
}, 2000)

console.log('Finish')

В обычных условиях код выполнится следующим образом:
1.Выполнится код Старт.
2.Выполнится код Финиш.
3.Выполнится код SetTimeOut, т.к. там стоит счетчик на 2000ms.

setTimeout(function(){
    console.log('Step 1')
    setTimeout(function(){
        console.log('Step 2')
        setTimeout(function(){
            console.log('Step 3')
        }, 100)
    }, 1500)
}, 2000)

В этом случаи все выполнится по порядку, т.к. в начале выполнится функция Step1,
затем Step2 и Step3.

Callback - обратный вызов.

//Проверить номера в отеле
//Проверить авиабилеты

function checkRooms(success, failed){
    setTimeout(function(){
        console.log('Проверяем номера в отеле...')
        const availableRooms = true

        if(availableRooms){
            let message = 'Номера есть'
            success(message)
        }else{
            let message = 'Номеров НЕТ'
            failed(message)
        }
    }, 1000)
}

function checkTickets(message, success, failed){
    setTimeout(function(){
        console.log('---- function checkTickets ----')
        console.log('Ответ на предыдущем шаге:', message)

        console.log('Проверяем авиабилеты...')
        const availableTickets = true

        if (availableTickets){
            let message = 'Билеты есть'
            success(message)
        } else{
            let message = 'Билетов нет'
            failed(message)
        }
    }, 500)
}

function cancelVacation(message){
    console.log('----cancelVacation---')
    console.log('Ответ на предыдущем шаге:', message)
    console.log('Отпуск отменяется  :(')
}

function submitVacation(message){
    console.log('----submitVacation---')
    console.log('Ответ на предыдущем шаге:', message)
    console.log('Едем в отпуск!  :)')
}

//Callback hell разростается и код уезжает вправо
checkRooms(
    function(messageFromCheckRooms){
        checkTickets(
            messageFromCheckRooms,
            function(messageFromCheckTickets){
                submitVacation(messageFromCheckTickets)
            },
            function(messageFromCheckTickets){
                cancelVacation(messageFromCheckTickets)
            })
    },
    function(messageFromCheckRooms){
        cancelVacation(messageFromCheckRooms)
    }
)

То есть, чем больше вложенность, тем труднее читать код.

Создание промиса
==================================================================================================
Promise - обещание
Resolve - разрешить
Reject - отказать

const myPromise = new Promise(function(resolve, reject){
    console.log('Promise created')
    setTimeout(function(){
       // - запрос на сервер
       const response = false

       if(response) {
           let message = 'SUCCESS'
           resolve(message)
       } else{
           let message = 'FAILED'
           reject(message)
       }
    }, 1000)
})

myPromise.then(function(data){
    console.log('Then')
    console.log(data)
}).catch(function(data){
    console.log('Catch')
    console.log(data)
})

Ассинхронность в then
==================================================================================================
const myPromise = new Promise(function(resolve, reject){
    console.log('Promise created')
    setTimeout(function(){
       // - запрос на сервер
       const response = false

       if(response) {
           let message = 'SUCCESS'
           resolve(message)
       } else{
           let message = 'FAILED'
           reject(message)
       }
    }, 1000)
})

myPromise.then(function(data){
    setTimeout(() =>{
        console.log('Then 1')
        console.log(data)
    }, 1000)
}).then(function(data){
    setTimeout(() => {
        console.log('Then 2')
    }, 500)
}).catch(function(data){
    console.log('Catch')
    console.log(data)
})

Then мы можем использовать сколько угодно, но они выполняются также с задержкой.
Если есть then меньше с задержкой, то в первую очередь выполнится он.

Как исправить ассинхронность в then
==================================================================================================
const myPromise = new Promise(function(resolve, reject){
    console.log('Promise created')
    setTimeout(function(){
       // - запрос на сервер
       const response = true

       if(response) {
           let message = 'SUCCESS'
           resolve(message)
       } else{
           let message = 'FAILED'
           reject(message)
       }
    }, 1000)
})

myPromise.then(function(data){

return new Promise(function(resolve, reject){
    setTimeout(()=>{
        console.log('Then 1')
        console.log(data)

        const response = true
        if (response){
            resolve('Data from then 1')
        } else{
            reject('Data from then 1')
        }
    }, 1000)
})

}).then(function(data){

    setTimeout(()=>{
        console.log('Then 2')
        console.log(data)
    },500)
}).catch(function(data){
    console.log('Catch')
    console.log(data)
})

Цепочка промисов. Несколько промисов с SetTimeOut
==================================================================================================
const checkRooms = new Promise(function(resolve, reject){
    setTimeout(function(){
        console.log('Проверяем номера в отеле...')
        const availableRooms = true

        if(availableRooms){
            resolve('Номера есть!')
        }else{
            reject('Номеров нет')
        }

    }, 1500)
})

checkRooms.then(function(data){
    return new Promise(function(resolve, reject){
       setTimeout(() =>{
           console.log('---- Then 1 ----')
           console.log('Ответ на предыдущем шаге', data)
           console.log('Проверяем авиабилеты...')
           const availableTickets = true

           if (availableTickets){
               let message = 'Билеты есть'
               resolve(message)
           }else{
               let message = 'Билетов нет'
               reject(message)
           }
       }, 1000)
})
}).then(function(data){
    console.log('---- Then 2 ----')
    console.log('Ответ на предыдущем шаге', data)
    console.log('Едем в отпуск!')
}).catch(function(data){
    console.log('---- catch ----')
    console.log('Ответ на предыдущем шаге', data)
    console.log('Отпуск отмеяется')
})

Цепочка промисов. Отдельные функции. Несколько промисов с SetTimeOut
==================================================================================================
checkRooms()
    .then(checkTickets)
    .then(success)
    .catch(failed)

function checkRooms(){
    return new Promise(function(resolve, reject){
        setTimeout(function(){
            console.log('Проверяем номера в отеле...')
            const availableRooms = true
    
            if(availableRooms){
                resolve('Номера есть!')
            }else{
                reject('Номеров нет')
            }
    
        }, 1500)
    })
}
function checkTickets(data){
    return new Promise(function(resolve, reject){
        setTimeout(() =>{
            console.log('---- Then 1 ----')
            console.log('Ответ на предыдущем шаге', data)
            console.log('Проверяем авиабилеты...')
            const availableTickets = true
 
            if (availableTickets){
                let message = 'Билеты есть'
                resolve(message)
            }else{
                let message = 'Билетов нет'
                reject(message)
            }
        }, 1000)
 })
}
function success(data){
    console.log('---- Success ----')
    console.log('Ответ на предыдущем шаге', data)
    console.log('Едем в отпуск!')
}
function failed(data){
    console.log('---- Failed ----')
    console.log('Ответ на предыдущем шаге', data)
    console.log('Отпуск отмеяется')
}

Async functions. Ассинхронные функциии. Потребление промиса.
==================================================================================================
function promiseFunction(arguments) {
    return new Promise(function(resolve, reject) {
        setTimeout(() => {
            const result = false
            if (result){
                resolve('DONE!')
            }else{
                reject('FAIL!')
            }
        }, 500)
    })
}

async function startPromise(){
    try {
        const result = await promiseFunction()
        console.log(result)
    } catch (err) {
        console.log(err)
    }
    
}

startPromise()

Несколько ассинхронных операцийю Серия промисов.
==================================================================================================
function checkRooms(){
    return new Promise(function(resolve, reject){
        setTimeout(function(){
            console.log('Проверяем номера в отеле...')
            let availableRooms = true
    
            if(availableRooms){
                resolve('Номера есть!')
            }else{
                reject('Номеров нет')
            }
    
        }, 1500)
    })
}

function checkTickets(data){
    return new Promise(function(resolve, reject){
        setTimeout(() =>{
            console.log('---- checkTickets ----')
            console.log('Ответ на предыдущем шаге', data)
            console.log('Проверяем авиабилеты...')
            let availableTickets = true
 
            if (availableTickets){
                let message = 'Билеты есть'
                resolve(message)
            }else{
                let message = 'Билетов нет'
                reject(message)
            }
        }, 1000)
 })
}

function submitVacation(data){
    console.log('---- Success ----')
    console.log('Ответ на предыдущем шаге', data)
    console.log('Едем в отпуск!')
}

function cancelVacation(data){
    console.log('---- Failed ----')
    console.log('Ответ на предыдущем шаге', data)
    console.log('Отпуск отмеяется')
}

async function checkVacation() {
    try{
        const roomsResult = await checkRooms()
        const ticketsResult = await checkTickets(roomsResult)
        submitVacation(ticketsResult)
    } catch (err){
        cancelVacation(ticketsResult)
    }
}

checkVacation()

fetch с промисами получение данных по API
==================================================================================================
//1.Получить данные с сервера(через then)

fetch('https://www.cbr-xml-daily.ru/daily_json.js')
.then(function(data){
   return data.json()
})
.then(function(){
    console.log(data)
})

//1.Получить данные с сервера(через async)

fetch('https://www.cbr-xml-daily.ru/daily_json.js')

async function getCurrencies(){
   const response = await fetch('https://www.cbr-xml-daily.ru/daily_json.js')
   const data = await response.json()

   console.log(data)
}

getCurrencies()


//1.Получить данные с сервера

fetch('https://www.cbr-xml-daily.ru/daily_json.js')

async function getCurrencies(){
   const response = await fetch('https://www.cbr-xml-daily.ru/daily_json.js')
   const data = await response.json()

   console.log(data.Valute.USD.Value.toFixed(2))
   console.log(data.Valute.EUR.Value.toFixed(2))

   const usdRate = data.Valute.USD.Value.toFixed(2)
   const eurRate = data.Valute.EUR.Value.toFixed(2)

   //2.Отобразить эти данные на странице
   const usdElement = document.querySelector('#usd')
   const eurElement = document.querySelector('#eur')

   usdElement.innerText = usdRate
   eurElement.innerText = eurRate
}

getCurrencies()


Для того, чтобы работать с данными из ассинхронной функции используем
следующий метод:

fetch('https://www.cbr-xml-daily.ru/daily_json.js')

async function getCurrencies(){
   const response = await fetch('https://www.cbr-xml-daily.ru/daily_json.js')
   const data = await response.json()
   renderRates(data)
}

getCurrencies()

function renderRates(data){
   const usdRate = data.Valute.USD.Value.toFixed(2)
   const eurRate = data.Valute.EUR.Value.toFixed(2)

   
   const usdElement = document.querySelector('#usd')
   const eurElement = document.querySelector('#eur')

   usdElement.innerText = usdRate
   eurElement.innerText = eurRate
}