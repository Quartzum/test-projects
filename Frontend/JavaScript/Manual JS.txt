1)Переменная и постоянная.
==================================================================================================
Это контейнер, в котором мы можем хранить значения.

1)let - переменная, в которой значение можно поменять.
2)const - постоянная, в которой значение не меняется.
3)var - тоже самое, что и let. Использовался до ES5.
Примечание: отличается от let тем, что интерпретатор видит его даже внутри функции.

Лучше всего использовать всегда const!!!!!

Пример:

1)let name = 'name'
2)const name = 'name'
3)var name = 'name'

Название перменных:

Можно начинать ее со спец.символа:

const _name = name
const _ = n

Нельзя называть переменную зарезервированными словами в языке(типо is, for и т.п.)
Нельзя называть переменную начиная с цифры(9name - нельзя)

2)Мутирование.
==================================================================================================
const nameName = 144
console.log('Введите данные: ' + nameName)

Здесь произойдет процесс конкатенации. То есть первое значение склеиться со вторым значением.
При этом переменная Name станет строкой, а не числом,как было до этого. 
Это происходит из-за того, что строка главнее числа. 
Есть специальная таблица по которой можно определить важность данных.

3)Типы данных.
==================================================================================================
1)'string' - string(строка).
2)23 - number(число).
3)true/false - boolean(булево число). Может принимать значение true или false.
4)null - null(ничего). Значение неизвестно. Используют для сброса значения переменной.
5)undefind - значение не определенно. Пример - let name. 
Здесь в значение ничего не записано, поэтому оно будет выводится, как undefind.

6)BigInt - встроенный объект, который позволяет создавать большие числа. 
Если необходимо выйти за Number_Max_integer, то нужно использовать BigInt.
7)Symbol - это уникальное примитивное значение. 
Позволяет добавлять уникальное свойство к объекту, с уверенностью,
что он не перезапишет никакое другое свойство.

4)Операторы сравнения и условия.
==================================================================================================
> - больше
< - меньше
>= - больше, либо равно.
<= - меньше, либо равно.
== - нестрогое сравнение.
=== - строгое сравнение.
!= - нестрогое неравенство.
!== - строгое неравенство.

if(условие){} - оператор условия если. Если условие верно, 
то он выполнит часть в фигурных скобках.

else{} - оператор условия иначе. Если условия выше else не верны, 
то он выполнит часть кода в фигурных скобках.

5)Логические операторы.
==================================================================================================
&& - логическое И.
|| - логическое ИЛИ.
!true - логическое НЕ.

6)Тернарный оператор.
==================================================================================================
Это упрощенная конструкция с операторами if и else.

1)Конструкция на If/else:

let greeting
let time = 10

if (time < 12){
    greeting = 'Доброе утро'
} else{
    greeting = 'Добрый день'
}

console.log(greeting)

2)Конструкция на тернарном операторе:

let time = 10
greeting = time < 12 ? 'Доброе утро' : 'Добрый день'
console.log(greeting)

7)Конкатенация строк и шаблонные строки.
==================================================================================================
Конкатенация - сложение строк.

let greeting = 'Привет, Марк!'
let howAreTou = 'Как твои дела?'
let sayHi = greeting + howAreTou
console.log(sayHi)

Шаблонные строки - это строки, в которые напрямую можно вставить значение переменной.
Плюс в том, что не происходит перетипизация переменной
(то есть не происходит переход от одного типа данных
к другому и как следствие не будет случайных ошибок).

Объявляется при помощи обратных скобок `` и там, где мы хотим вставить переменную ${}

console.log(`Привет, ${userName}! Как твои дела?`)

8)Функции.
==================================================================================================
Функция - это конструкция, которая позволяет вызывать ее внутри кода неограниченное количество раз.

function name(){
}

function(name)

1)Function declaration - это функция, которая находится в глобальном коде, а не внутри какой-то 
переменной или постоянной. Мы ее можем вызвать в любое время.

function sayHi()

function sayHi(){
    alert('Привет')
}


2)Function expression - это функция, которая записывается в переменную или постоянную

const sayHi = function(){
    alert('Привет')
}

function sayHi()

Если вызвать функцию раньше написания самой функции, то выдаст ошибку.

8.1)Параметры и аргументы для функции.
==================================================================================================
function sayHi(name){
    console.log(`Привет, ${name}! Как твои дела?`)
}

sayHi('Yurij')

name - Параметр
Yurij - Аргумент

8.2)Функция Return.
==================================================================================================
Функция Return - завершает выполнение текущей функции и возвращает её значение
(чаще всего в какую-то переменную или постоянную).

function summ(a, b){
    const result = a + b 
    return result;
}

let res = summ(10, 15)
console.log(res)

8.3)Функция, как аргумент.
==================================================================================================
function summ(a, b){
    return a+b
}

console.log(summ(10, 15))

const result = summ(summ(15, 15), summ(20, 20))

8.4)Самовызывающаяся функция IIFE.
==================================================================================================
Immediately involve function expression - Незамедлительно Вызывающееся Функциональное выражение.

Пример:

(function sayHi(){
    console.log('Привет, дорогой пользователь!');
})();

То есть можно не вызывать отдельно где-то функцию, а вызвать ее внутри нее.

(function(){
    console.log('Привет, дорогой пользователь!');
})();

Также можно сделать анонимную IIFE, как примером выше.

ТАКЖЕ ОБЯЗАТЕЛЬНО СТАВИТЬ ТОЧКУ С ЗАПЯТОЙ В КОНЦЕ ФУНКЦИИ!!!

В круглые скобки в конце вносим аргументы функции.

8.5)Стрелочные функции.
==================================================================================================
Выражения стрелочных функций имеют более короткий синтаксис по сравнению
с функциональными выражениями и лексически привязаны к значению this.
(но не привязаны к собственному this, arguments, super, или new.target). 
Выражение стрелочных функций не позволяют задавать имя, поэтому стрелочные функции анонимны, 
если их ни к чему не присвоить.

const SayHi = (name) => {
    console.log(`Привет, ${name}! Как твои дела?`)
}
SayHi()

const sayHi = (name) => console.log(`Привет, ${name}! Как твои дела?`)
sayHi('Марк')

const summ = (a, b) => a + b

9)Массивы.
==================================================================================================
Это коллекция данных

Если в коде есть [], то это либо array(массив), либо массивоподобные конструкции.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']
console.log(autoBrands)

Если нужно вывести конкретный элемент внутри массива, то можно использовать следующую команду:

console.log(autoBrands[0]) - отсчет начинается с 0.

console.log(autoBrands.length) - длинна массива

Внутрь массива можно внести другой массив.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota', [2,3,4]]

9.1)Методы массивов.
==================================================================================================
1).push() - добавляет элемент в конец массива.
2).pop() - удалить элемент из конца массива.
3).shift() - удалить элемент из начала массива.
4).unshift() - добавь элемент в начало массива.
5).splice() - удалить элемент с какого-то конкретного места.
6).slice() - вырезает и возвращает указанную часть массива.
7).forEach() - позволяет последовательно перебрать все элементы массива.
8).indexOf()  - возвращает первый индекс, по которому данный элемент может быть
найден в массиве или -1, если такого индекса нет.
9).includes() - определяет, содержит ли массив определённый элемент, 
возвращая в зависимости от этого true или false.

Примеры:

autoBrands.push(23)
autoBrands.pop(43)
autoBrands.shift(6)
autoBrands.unshift(4)
autoBrands.splice(2, 1) - начать со второго элемента, а второй параметр указывает
на количество удалений.

массив.slice(откуда отрезать, 
	[докуда отрезать]

массив.forEach(function(элемент, индекс, 
	массив) { 
	код, который выполнится для всех 
		элементов 
})

arr.indexOf(searchElement[, fromIndex = 0])

arr.includes(searchElement[, fromIndex = 0])

10)Циклы.
==================================================================================================
Он позволяет запустить код несколько раз, пока цикл не закончится.

console.log('Start')

for(let i = 0; i < 10; i++){
    console.log(i)
}

console.log('Finish')

Первый параметр - количество циклов.
Второй параметр - условие цикла.
Третий параметр - что мы делаем с циклом.


11.1)Обход массива циклом for.
==================================================================================================
При помощи него можно пройтись по каждому элементу через индекс(или что-то еще)массива

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']
for (i = 0; i < autoBrands.length; i++){
    console.log(autoBrands[i])
}

11.2)Обход массива циклом for (of)
==================================================================================================
Более легкий и лаконичный способ обхода массива с самого начала.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']

for(let brand of autoBrands){
    console.log(brand)
}

11.3)Обход массива методом forEach().
==================================================================================================
Функцию внутри метода можно сразу написать.

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']

autoBrands.forEach(function(item, index){
    console.log(`${item} => ${index}`)
})

Или можно описать функцию где-то ниже...

autoBrands.forEach(printBrand)

function printBrand(item, index){
    console.log(`${item} => ${index}`)
})

Также можно вызвать функцию через метод и передать ей значения

autoBrands.forEach(printBrand(1, 2))

function printBrand(item, index){
    console.log(`${item} => ${index}`)
})

Также стрелочная функция при этом методе

autoBrands.forEach((brand, i) =>console.log(`${brand} => ${i}`))


12)Объекты.
==================================================================================================
let userName = 'Марк'
let age = 30
let isMarried = false

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    profession: 'Designer'
}

console.log(person)

console.log(person.userName) - обращение по свойству
console.log(person['age']) - обращение по свойству. Лучше всего использовать, когда
свойство занесено в переменную.

let propertyName = 'profession'
const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    profession: 'Designer'
}

console.log(person[propertyName])

person.profession = 'JS developer' - так можно добавить свойство в объект.

delete person.age - удаление свойства
console.log(person)


12.1)Методы в объектах
==================================================================================================
Функция, которая принадлежит объекту называется методом объекта.
Остальное, что внутри объекта это свойства(юзер нейм, возраст ...)

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(){
        console.log('Привет!')
    }
}

person.sayHi() - запуск метода

person.sayHi = function(){      - добавить метод в объект
        console.log('Привет!')
    }

person.sayHi()


person.sayHi = function(name){    - добавить параметр в метод объекта
    console.log(`Привет, ${name}`)
}

person.sayHi('Юрий')

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(name){
        console.log(`Привет, ${name}!`)
    }
}

person.sayHi('Юрий')


12.2)Ключевое слово this.
==================================================================================================
Ключевое слово this внутри метода объекта ссылается на объект.

Можно обратиться напрямую к объекту person на свойство userName, но проблема в том,
что мы обращаемся внутри объекта на объект.

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(name){
        console.log(`Привет, ${name}! Меня зовут ${person.userName}.`)
    }
}

person.sayHi('Юрий')

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(name){
        console.log(this)
        console.log(`Привет, ${name}! Меня зовут ${this.userName}.`)
    }
}

person.sayHi('Юрий')

12.3)Объекты обход циклом for in (не путать с for of).
==================================================================================================
const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
    sayHi: function(yourName){
        console.log(this)
        console.log(`Привет, ${yourName}! Меня зовут ${this.userName}.`)
    }
}

for (let key in person){
    console.log(key) - обычный обход по ключу
    console.log(key, ':', person[key]) - обход по ключу, + значение свойств.

12.4)Нюанс const и изменение объекта и массива.
==================================================================================================
При попытки добавить что-то в объект это не будет ошибкой.

const person = {
    userName: 'Марк',
    age: 30,
    isMarried: false,
}

person.proff = 'Designer'

Ошибка! Переопределение ссылки на новый объект.

person = {
    userName = 'Ник'
}

13)Классы. Конструкторы объектов.
==================================================================================================
Используются, когда нужно описать большое количество объектов.

Класс, это как чертеж для всех будущих объектов person, которые будут создаваться на его основе

class Person{
    constructor(userName, age, isMarried){
        this.userName = userName
        this.age = age
        this.isMarried = isMarried
    }

    sayHi(name){
        console.log(`Привет, ${name}! Меня зовут ${this.userName}.`)
    }
}

const person1 = new Person('Марк', 30, false)
const person2 = new Person('Павел', 28, true)

console.log(person1)
person1.sayHi('Юрий')

==================================================================================================
==================================================================================================
==================================================================================================
==================================================================================================
Web конструкции JavaScipt
==================================================================================================
==================================================================================================
==================================================================================================
==================================================================================================

1)Выбор DOM элементов
==================================================================================================
document - обращение к документу(в данном случаи, к HTML).
querySelector - обращение к селектору(тегу, классу, ID).
В скобках можно использовать составные теги(h2.heading ...).

document.querySelector('selector') - структура.
document.querySelector('.heading-3').classList.add('green') - добавление свойства CSS по классу.

Метод querySelector - работает только с первым селектором, который попадется.

document.querySelectorAll('selector') - работа с несколькими селекторами одновременно.

Не работает без цикла for.

1.1)Выбор коллекции элементов через цикл for of.
==================================================================================================
1)Ищем все теги h2.

const headings = document.querySelectorAll('h2')
console.log(headings)

2)Проходимся циклом for для заголовков и красим текст к красный.
for (let heading of headings) {
    heading.classList.add('red-text')
}

1.2)Выбор коллекции элементов через цикл forEach.
==================================================================================================
const paragraphs = document.querySelectorAll('p')
paragraphs.forEach(function (item){
    item.classList.add('green-text')
})

Старые методы:

document.getElementsByClassName('selector') - выбор коллекции элементов по CSS классу(нельзя использовать с циклом
forEach. Либо ее будет нужно превратить в массив).
document.getElementsByTagName('selector') - выбор коллекции элементов по тегу
document.getElementById('selector') -lin выбор одного элемента по ID

Точки и # во всех методах писать не надо, т.к. метод подразумевает,
что мы работаем с классами и ID.

2)Работа с CSS классами.
==================================================================================================
1)element.classList.add() - на первом месте класс, на втором класс метода, на третьем метод.
2).add() - добавить CSS класс.
3).remove() - удалить CSS класс.
4).toggle() - добавляет или убирает CSS класс(в зависимости от того есть он там или нет).
5).contains() - возвращает true или false в зависимости от того есть такой класс или нет.

2.1)Работа с атрибутами.
==================================================================================================
1)getAttribute(attrName) - возвращает значение указаного атрибута.
2)setAttribute(name, value) - добавляет указанные атрибут и значение к элементу.
3)hasAttribute(attrName) - возвращает true при наличии у элемента указанного атрибута.
4)removeAttribute(attrName) - удаляет указанный атрибут.
5)toggleAttribute(name, force) - добавляет новый атрибут при отсутствии
или удаляет существующий атрибут.
6)hasAttributes() - возвращает true, если у элемента имеются какие-либо атрибуты.
7)getAttributesNames() - возвращает названия атрибутов элемента.